{"version":3,"file":"actioncable.46f32c4c31b7ee7217d3.js","mappings":"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","sources":["webpack://foto/./node_modules/@rails/actioncable/src/adapters.js","webpack://foto/./node_modules/@rails/actioncable/src/logger.js","webpack://foto/./node_modules/@rails/actioncable/src/connection_monitor.js","webpack://foto/./node_modules/@rails/actioncable/src/internal.js","webpack://foto/./node_modules/@rails/actioncable/src/connection.js","webpack://foto/./node_modules/@rails/actioncable/src/subscription.js","webpack://foto/./node_modules/@rails/actioncable/src/subscriptions.js","webpack://foto/./node_modules/@rails/actioncable/src/consumer.js","webpack://foto/./node_modules/@rails/actioncable/src/index.js"],"sourcesContent":["export default {\n  logger: self.console,\n  WebSocket: self.WebSocket\n}\n","import adapters from \"./adapters\"\n\n// The logger is disabled by default. You can enable it with:\n//\n//   ActionCable.logger.enabled = true\n//\n//   Example:\n//\n//   import * as ActionCable from '@rails/actioncable'\n//\n//   ActionCable.logger.enabled = true\n//   ActionCable.logger.log('Connection Established.')\n//\n\nexport default {\n  log(...messages) {\n    if (this.enabled) {\n      messages.push(Date.now())\n      adapters.logger.log(\"[ActionCable]\", ...messages)\n    }\n  },\n}\n","import logger from \"./logger\"\n\n// Responsible for ensuring the cable connection is in good health by validating the heartbeat pings sent from the server, and attempting\n// revival reconnections if things go astray. Internal class, not intended for direct user manipulation.\n\nconst now = () => new Date().getTime()\n\nconst secondsSince = time => (now() - time) / 1000\n\nconst clamp = (number, min, max) => Math.max(min, Math.min(max, number))\n\nclass ConnectionMonitor {\n  constructor(connection) {\n    this.visibilityDidChange = this.visibilityDidChange.bind(this)\n    this.connection = connection\n    this.reconnectAttempts = 0\n  }\n\n  start() {\n    if (!this.isRunning()) {\n      this.startedAt = now()\n      delete this.stoppedAt\n      this.startPolling()\n      addEventListener(\"visibilitychange\", this.visibilityDidChange)\n      logger.log(`ConnectionMonitor started. pollInterval = ${this.getPollInterval()} ms`)\n    }\n  }\n\n  stop() {\n    if (this.isRunning()) {\n      this.stoppedAt = now()\n      this.stopPolling()\n      removeEventListener(\"visibilitychange\", this.visibilityDidChange)\n      logger.log(\"ConnectionMonitor stopped\")\n    }\n  }\n\n  isRunning() {\n    return this.startedAt && !this.stoppedAt\n  }\n\n  recordPing() {\n    this.pingedAt = now()\n  }\n\n  recordConnect() {\n    this.reconnectAttempts = 0\n    this.recordPing()\n    delete this.disconnectedAt\n    logger.log(\"ConnectionMonitor recorded connect\")\n  }\n\n  recordDisconnect() {\n    this.disconnectedAt = now()\n    logger.log(\"ConnectionMonitor recorded disconnect\")\n  }\n\n  // Private\n\n  startPolling() {\n    this.stopPolling()\n    this.poll()\n  }\n\n  stopPolling() {\n    clearTimeout(this.pollTimeout)\n  }\n\n  poll() {\n    this.pollTimeout = setTimeout(() => {\n      this.reconnectIfStale()\n      this.poll()\n    }\n    , this.getPollInterval())\n  }\n\n  getPollInterval() {\n    const {min, max, multiplier} = this.constructor.pollInterval\n    const interval = multiplier * Math.log(this.reconnectAttempts + 1)\n    return Math.round(clamp(interval, min, max) * 1000)\n  }\n\n  reconnectIfStale() {\n    if (this.connectionIsStale()) {\n      logger.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, pollInterval = ${this.getPollInterval()} ms, time disconnected = ${secondsSince(this.disconnectedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`)\n      this.reconnectAttempts++\n      if (this.disconnectedRecently()) {\n        logger.log(\"ConnectionMonitor skipping reopening recent disconnect\")\n      } else {\n        logger.log(\"ConnectionMonitor reopening\")\n        this.connection.reopen()\n      }\n    }\n  }\n\n  connectionIsStale() {\n    return secondsSince(this.pingedAt ? this.pingedAt : this.startedAt) > this.constructor.staleThreshold\n  }\n\n  disconnectedRecently() {\n    return this.disconnectedAt && (secondsSince(this.disconnectedAt) < this.constructor.staleThreshold)\n  }\n\n  visibilityDidChange() {\n    if (document.visibilityState === \"visible\") {\n      setTimeout(() => {\n        if (this.connectionIsStale() || !this.connection.isOpen()) {\n          logger.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`)\n          this.connection.reopen()\n        }\n      }\n      , 200)\n    }\n  }\n\n}\n\nConnectionMonitor.pollInterval = {\n  min: 3,\n  max: 30,\n  multiplier: 5\n}\n\nConnectionMonitor.staleThreshold = 6 // Server::Connections::BEAT_INTERVAL * 2 (missed two pings)\n\nexport default ConnectionMonitor\n","export default {\n  \"message_types\": {\n    \"welcome\": \"welcome\",\n    \"disconnect\": \"disconnect\",\n    \"ping\": \"ping\",\n    \"confirmation\": \"confirm_subscription\",\n    \"rejection\": \"reject_subscription\"\n  },\n  \"disconnect_reasons\": {\n    \"unauthorized\": \"unauthorized\",\n    \"invalid_request\": \"invalid_request\",\n    \"server_restart\": \"server_restart\"\n  },\n  \"default_mount_path\": \"/cable\",\n  \"protocols\": [\n    \"actioncable-v1-json\",\n    \"actioncable-unsupported\"\n  ]\n}\n","import adapters from \"./adapters\"\nimport ConnectionMonitor from \"./connection_monitor\"\nimport INTERNAL from \"./internal\"\nimport logger from \"./logger\"\n\n// Encapsulate the cable connection held by the consumer. This is an internal class not intended for direct user manipulation.\n\nconst {message_types, protocols} = INTERNAL\nconst supportedProtocols = protocols.slice(0, protocols.length - 1)\n\nconst indexOf = [].indexOf\n\nclass Connection {\n  constructor(consumer) {\n    this.open = this.open.bind(this)\n    this.consumer = consumer\n    this.subscriptions = this.consumer.subscriptions\n    this.monitor = new ConnectionMonitor(this)\n    this.disconnected = true\n  }\n\n  send(data) {\n    if (this.isOpen()) {\n      this.webSocket.send(JSON.stringify(data))\n      return true\n    } else {\n      return false\n    }\n  }\n\n  open() {\n    if (this.isActive()) {\n      logger.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`)\n      return false\n    } else {\n      logger.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${protocols}`)\n      if (this.webSocket) { this.uninstallEventHandlers() }\n      this.webSocket = new adapters.WebSocket(this.consumer.url, protocols)\n      this.installEventHandlers()\n      this.monitor.start()\n      return true\n    }\n  }\n\n  close({allowReconnect} = {allowReconnect: true}) {\n    if (!allowReconnect) { this.monitor.stop() }\n    if (this.isActive()) {\n      return this.webSocket.close()\n    }\n  }\n\n  reopen() {\n    logger.log(`Reopening WebSocket, current state is ${this.getState()}`)\n    if (this.isActive()) {\n      try {\n        return this.close()\n      } catch (error) {\n        logger.log(\"Failed to reopen WebSocket\", error)\n      }\n      finally {\n        logger.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`)\n        setTimeout(this.open, this.constructor.reopenDelay)\n      }\n    } else {\n      return this.open()\n    }\n  }\n\n  getProtocol() {\n    if (this.webSocket) {\n      return this.webSocket.protocol\n    }\n  }\n\n  isOpen() {\n    return this.isState(\"open\")\n  }\n\n  isActive() {\n    return this.isState(\"open\", \"connecting\")\n  }\n\n  // Private\n\n  isProtocolSupported() {\n    return indexOf.call(supportedProtocols, this.getProtocol()) >= 0\n  }\n\n  isState(...states) {\n    return indexOf.call(states, this.getState()) >= 0\n  }\n\n  getState() {\n    if (this.webSocket) {\n      for (let state in adapters.WebSocket) {\n        if (adapters.WebSocket[state] === this.webSocket.readyState) {\n          return state.toLowerCase()\n        }\n      }\n    }\n    return null\n  }\n\n  installEventHandlers() {\n    for (let eventName in this.events) {\n      const handler = this.events[eventName].bind(this)\n      this.webSocket[`on${eventName}`] = handler\n    }\n  }\n\n  uninstallEventHandlers() {\n    for (let eventName in this.events) {\n      this.webSocket[`on${eventName}`] = function() {}\n    }\n  }\n\n}\n\nConnection.reopenDelay = 500\n\nConnection.prototype.events = {\n  message(event) {\n    if (!this.isProtocolSupported()) { return }\n    const {identifier, message, reason, reconnect, type} = JSON.parse(event.data)\n    switch (type) {\n      case message_types.welcome:\n        this.monitor.recordConnect()\n        return this.subscriptions.reload()\n      case message_types.disconnect:\n        logger.log(`Disconnecting. Reason: ${reason}`)\n        return this.close({allowReconnect: reconnect})\n      case message_types.ping:\n        return this.monitor.recordPing()\n      case message_types.confirmation:\n        return this.subscriptions.notify(identifier, \"connected\")\n      case message_types.rejection:\n        return this.subscriptions.reject(identifier)\n      default:\n        return this.subscriptions.notify(identifier, \"received\", message)\n    }\n  },\n\n  open() {\n    logger.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`)\n    this.disconnected = false\n    if (!this.isProtocolSupported()) {\n      logger.log(\"Protocol is unsupported. Stopping monitor and disconnecting.\")\n      return this.close({allowReconnect: false})\n    }\n  },\n\n  close(event) {\n    logger.log(\"WebSocket onclose event\")\n    if (this.disconnected) { return }\n    this.disconnected = true\n    this.monitor.recordDisconnect()\n    return this.subscriptions.notifyAll(\"disconnected\", {willAttemptReconnect: this.monitor.isRunning()})\n  },\n\n  error() {\n    logger.log(\"WebSocket onerror event\")\n  }\n}\n\nexport default Connection\n","// A new subscription is created through the ActionCable.Subscriptions instance available on the consumer.\n// It provides a number of callbacks and a method for calling remote procedure calls on the corresponding\n// Channel instance on the server side.\n//\n// An example demonstrates the basic functionality:\n//\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\", {\n//     connected() {\n//       // Called once the subscription has been successfully completed\n//     },\n//\n//     disconnected({ willAttemptReconnect: boolean }) {\n//       // Called when the client has disconnected with the server.\n//       // The object will have an `willAttemptReconnect` property which\n//       // says whether the client has the intention of attempting\n//       // to reconnect.\n//     },\n//\n//     appear() {\n//       this.perform('appear', {appearing_on: this.appearingOn()})\n//     },\n//\n//     away() {\n//       this.perform('away')\n//     },\n//\n//     appearingOn() {\n//       $('main').data('appearing-on')\n//     }\n//   })\n//\n// The methods #appear and #away forward their intent to the remote AppearanceChannel instance on the server\n// by calling the `perform` method with the first parameter being the action (which maps to AppearanceChannel#appear/away).\n// The second parameter is a hash that'll get JSON encoded and made available on the server in the data parameter.\n//\n// This is how the server component would look:\n//\n//   class AppearanceChannel < ApplicationActionCable::Channel\n//     def subscribed\n//       current_user.appear\n//     end\n//\n//     def unsubscribed\n//       current_user.disappear\n//     end\n//\n//     def appear(data)\n//       current_user.appear on: data['appearing_on']\n//     end\n//\n//     def away\n//       current_user.away\n//     end\n//   end\n//\n// The \"AppearanceChannel\" name is automatically mapped between the client-side subscription creation and the server-side Ruby class name.\n// The AppearanceChannel#appear/away public methods are exposed automatically to client-side invocation through the perform method.\n\nconst extend = function(object, properties) {\n  if (properties != null) {\n    for (let key in properties) {\n      const value = properties[key]\n      object[key] = value\n    }\n  }\n  return object\n}\n\nexport default class Subscription {\n  constructor(consumer, params = {}, mixin) {\n    this.consumer = consumer\n    this.identifier = JSON.stringify(params)\n    extend(this, mixin)\n  }\n\n  // Perform a channel action with the optional data passed as an attribute\n  perform(action, data = {}) {\n    data.action = action\n    return this.send(data)\n  }\n\n  send(data) {\n    return this.consumer.send({command: \"message\", identifier: this.identifier, data: JSON.stringify(data)})\n  }\n\n  unsubscribe() {\n    return this.consumer.subscriptions.remove(this)\n  }\n}\n","import Subscription from \"./subscription\"\n\n// Collection class for creating (and internally managing) channel subscriptions.\n// The only method intended to be triggered by the user is ActionCable.Subscriptions#create,\n// and it should be called through the consumer like so:\n//\n//   App = {}\n//   App.cable = ActionCable.createConsumer(\"ws://example.com/accounts/1\")\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\")\n//\n// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.\n\nexport default class Subscriptions {\n  constructor(consumer) {\n    this.consumer = consumer\n    this.subscriptions = []\n  }\n\n  create(channelName, mixin) {\n    const channel = channelName\n    const params = typeof channel === \"object\" ? channel : {channel}\n    const subscription = new Subscription(this.consumer, params, mixin)\n    return this.add(subscription)\n  }\n\n  // Private\n\n  add(subscription) {\n    this.subscriptions.push(subscription)\n    this.consumer.ensureActiveConnection()\n    this.notify(subscription, \"initialized\")\n    this.sendCommand(subscription, \"subscribe\")\n    return subscription\n  }\n\n  remove(subscription) {\n    this.forget(subscription)\n    if (!this.findAll(subscription.identifier).length) {\n      this.sendCommand(subscription, \"unsubscribe\")\n    }\n    return subscription\n  }\n\n  reject(identifier) {\n    return this.findAll(identifier).map((subscription) => {\n      this.forget(subscription)\n      this.notify(subscription, \"rejected\")\n      return subscription\n    })\n  }\n\n  forget(subscription) {\n    this.subscriptions = (this.subscriptions.filter((s) => s !== subscription))\n    return subscription\n  }\n\n  findAll(identifier) {\n    return this.subscriptions.filter((s) => s.identifier === identifier)\n  }\n\n  reload() {\n    return this.subscriptions.map((subscription) =>\n      this.sendCommand(subscription, \"subscribe\"))\n  }\n\n  notifyAll(callbackName, ...args) {\n    return this.subscriptions.map((subscription) =>\n      this.notify(subscription, callbackName, ...args))\n  }\n\n  notify(subscription, callbackName, ...args) {\n    let subscriptions\n    if (typeof subscription === \"string\") {\n      subscriptions = this.findAll(subscription)\n    } else {\n      subscriptions = [subscription]\n    }\n\n    return subscriptions.map((subscription) =>\n      (typeof subscription[callbackName] === \"function\" ? subscription[callbackName](...args) : undefined))\n  }\n\n  sendCommand(subscription, command) {\n    const {identifier} = subscription\n    return this.consumer.send({command, identifier})\n  }\n}\n","import Connection from \"./connection\"\nimport Subscriptions from \"./subscriptions\"\n\n// The ActionCable.Consumer establishes the connection to a server-side Ruby Connection object. Once established,\n// the ActionCable.ConnectionMonitor will ensure that its properly maintained through heartbeats and checking for stale updates.\n// The Consumer instance is also the gateway to establishing subscriptions to desired channels through the #createSubscription\n// method.\n//\n// The following example shows how this can be set up:\n//\n//   App = {}\n//   App.cable = ActionCable.createConsumer(\"ws://example.com/accounts/1\")\n//   App.appearance = App.cable.subscriptions.create(\"AppearanceChannel\")\n//\n// For more details on how you'd configure an actual channel subscription, see ActionCable.Subscription.\n//\n// When a consumer is created, it automatically connects with the server.\n//\n// To disconnect from the server, call\n//\n//   App.cable.disconnect()\n//\n// and to restart the connection:\n//\n//   App.cable.connect()\n//\n// Any channel subscriptions which existed prior to disconnecting will\n// automatically resubscribe.\n\nexport default class Consumer {\n  constructor(url) {\n    this._url = url\n    this.subscriptions = new Subscriptions(this)\n    this.connection = new Connection(this)\n  }\n\n  get url() {\n    return createWebSocketURL(this._url)\n  }\n\n  send(data) {\n    return this.connection.send(data)\n  }\n\n  connect() {\n    return this.connection.open()\n  }\n\n  disconnect() {\n    return this.connection.close({allowReconnect: false})\n  }\n\n  ensureActiveConnection() {\n    if (!this.connection.isActive()) {\n      return this.connection.open()\n    }\n  }\n}\n\nexport function createWebSocketURL(url) {\n  if (typeof url === \"function\") {\n    url = url()\n  }\n\n  if (url && !/^wss?:/i.test(url)) {\n    const a = document.createElement(\"a\")\n    a.href = url\n    // Fix populating Location properties in IE. Otherwise, protocol will be blank.\n    a.href = a.href\n    a.protocol = a.protocol.replace(\"http\", \"ws\")\n    return a.href\n  } else {\n    return url\n  }\n}\n","import Connection from \"./connection\"\nimport ConnectionMonitor from \"./connection_monitor\"\nimport Consumer, { createWebSocketURL } from \"./consumer\"\nimport INTERNAL from \"./internal\"\nimport Subscription from \"./subscription\"\nimport Subscriptions from \"./subscriptions\"\nimport adapters from \"./adapters\"\nimport logger from \"./logger\"\n\nexport {\n  Connection,\n  ConnectionMonitor,\n  Consumer,\n  INTERNAL,\n  Subscription,\n  Subscriptions,\n  adapters,\n  createWebSocketURL,\n  logger,\n}\n\nexport function createConsumer(url = getConfig(\"url\") || INTERNAL.default_mount_path) {\n  return new Consumer(url)\n}\n\nexport function getConfig(name) {\n  const element = document.head.querySelector(`meta[name='action-cable-${name}']`)\n  if (element) {\n    return element.getAttribute(\"content\")\n  }\n}\n"],"names":["logger","self","console","WebSocket","log","messages","this","enabled","push","Date","now","adapters","getTime","secondsSince","time","ConnectionMonitor","constructor","connection","visibilityDidChange","bind","reconnectAttempts","start","isRunning","startedAt","stoppedAt","startPolling","addEventListener","getPollInterval","stop","stopPolling","removeEventListener","recordPing","pingedAt","recordConnect","disconnectedAt","recordDisconnect","poll","clearTimeout","pollTimeout","setTimeout","reconnectIfStale","min","max","multiplier","pollInterval","interval","Math","round","number","clamp","connectionIsStale","staleThreshold","disconnectedRecently","reopen","document","visibilityState","isOpen","message_types","protocols","supportedProtocols","slice","length","indexOf","Connection","consumer","open","subscriptions","monitor","disconnected","send","data","webSocket","JSON","stringify","isActive","getState","uninstallEventHandlers","url","installEventHandlers","close","allowReconnect","error","reopenDelay","getProtocol","protocol","isState","isProtocolSupported","call","states","state","readyState","toLowerCase","eventName","events","handler","prototype","message","event","identifier","reason","reconnect","type","parse","welcome","reload","disconnect","ping","confirmation","notify","rejection","reject","notifyAll","willAttemptReconnect","Subscription","params","mixin","object","properties","key","value","extend","perform","action","command","unsubscribe","remove","Subscriptions","create","channelName","channel","subscription","add","ensureActiveConnection","sendCommand","forget","findAll","map","filter","s","callbackName","args","Consumer","_url","createWebSocketURL","connect","test","a","createElement","href","replace","createConsumer","getConfig","name","element","head","querySelector","getAttribute"],"sourceRoot":""}